# JIT Compiler

LMNT's JIT compiler speeds up execution of functions by compiling them into native code when they are loaded.

The JIT makes use of [a fork of the DynASM library](https://github.com/Esvandiary/DynASM), the [original version](https://github.com/LuaJIT/LuaJIT/tree/v2.1/dynasm) of which was created by Mike Pall as part of the LuaJIT project. The fork adds support for the ARMv7-M (Thumb-2) architecture.


## Workflow

1. The archive is loaded and validated as normal (`lmnt_ictx_load_archive`, `lmnt_ictx_prepare_archive`)
2. The user selects an LMNT function (`lmnt_ictx_find_def`)
3. This function is compiled to native code (`lmnt_jit_compile`)
4. The user chooses the inputs to use (`lmnt_update_args`)
5. The native function is executed instead of using the interpreter (`lmnt_jit_execute`)


## The JIT Compilation Process

This gives an overview of the compilation process performed by `lmnt_jit_compile` - more details on each step follow later.

First we initialise various aspects of DynASM, and generate a function prologue. Then, we iterate over each instruction in turn, generating native code which corresponds to those LMNT instructions.

Once we've finished encoding the function's instructions, we generate a function epilogue (including setting the return code to success or failure depending on the function's validity).

After we've finished generating all the instructions we want, we ask DynASM to link the function. This allows DynASM to tell us the exact size of the resulting native function, allowing us to provide a buffer of sufficient size (or produce an error if we can't provide such a buffer).

Once we've got a suitable buffer, we ask DynASM to encode the function, writing the native code into the buffer. This also writes the address of any labels present in the JIT'd code (including the label representing the start of the function) into an array. We can then populate a structure containing the buffer information and the pointer to the compiled function.


## Register Allocation

During compilation of a function, the LMNT JIT tracks the contents of the floating-point registers (XMM registers `xmm0-xmm15` on x86_64, VFP registers `s0-s31` on ARM), essentially acting as a register cache. This means that "hot" stack locations in the LMNT function can remain in registers to avoid going back and forth to RAM unnecessarily.

Several FP registers are reserved as temporary "scratch" locations for intermediate results in operations; the amount is typically sufficient for two 4-wide vectors. These are usually defined near the top of the JIT source file, but currently are `xmm0-xmm1` on x86_64, and `s0-s7` on armv7m.

Care must be taken with logic around use of this cache: since we can either be using a register as part of a scalar or a vector operation, cache coherence can easily be undermined accidentally. Helper functions are present to avoid manual checking; these are architecture-specific since access mechanisms are different between x86 (where scalar access is only immediately possible in the "first" lane of an XMM register) and ARM (where scalar access is possible to any lane of a VFP register).

Since most execution in LMNT is linear, the register cache has been optimised to be fast for this use case. As a result, some operations cause part or all of the cache to be flushed to ensure cache coherence:
* Returning (inevitable, as we need the end result to be accurate)
* Branch instructions (we don't know what the state is at the location we're jumping to)
* Any instruction which is the target of a branch (if we just branched to here, we have no cache)
* External calls, e.g. C function calls (volatile registers must be flushed since the external function may legally clobber them)


## DynASM: A Primer

Using DynASM makes creation of the JIT compiler much easier, but it is a tool with its own learning curve. There is [unofficial documentation](https://corsix.github.io/dynasm-doc/index.html) for the upstream project, almost all of which also applies to the fork used in LMNT.

DynASM's work is performed in two stages:

1. **Preprocessing**, "the LUA stage": a templated C source file (`*.dasc`) is processed into a C source file (typically using a pre-build step) and that C source file is compiled
2. **Compilation**, "the C stage": the code in the generated source is run with an input of a requested function's LMNT bytecode to JIT-compile the native function

The assembly instructions are generated by lines starting with a single `|` character, followed by instruction definitions:

```c
| addss xmm1, xmm0
```

For the most part, the syntax of the assembly aims to mimic "normal" syntax (Intel syntax for x86); there are a few places where the syntax differs slightly between architectures.

Note that the assembly instructions are _generated_ at this point, not _executed_. During the preprocessing stage, these lines are translated into C function calls to `dasm_put`. Then, during the compilation stage, these calls result in native instructions being added to a buffer for later execution.

Unlike normal assembly, these instructions can contain arguments which are dynamically calculated at runtime in C source:

```c
uint32_t src = 3, dst = 4;
| addss xmm(dst), xmm(src)
```

This allows us to decide which registers, immediates and memory addresses to use for any given operation during the compilation stage - in the case of the LMNT JIT, it means we can create a register caching mechanism to minimise how often we interact with main memory.

### Labels

DynASM can generate and use several different types of labels.

Local labels are useful for near branching to locally-accessible code:

```c
|1:
| add rax, 1
| cmp rax, 10
| jl <1
```

Local labels using `<N` jump to the nearest label with this number _before_ that instruction, and `>N` to the nearest matching label _after_ that instruction.

Global labels are defined once with a unique name and are usable from anywhere else:

```c
|->example:
| add rax, 1
| cmp rax, 10
| jl ->example
```

Dynamic (PC-relative) labels are global labels that are dynamically generated during JIT compilation (e.g. by branch instructions). The number of PC labels must be calculated before doing the main compilation, and passed into `dasm_growpc` to ensure sufficient storage space.

```c
dasm_growpc(&dasm_state, 1);
uint32_t cur_branch = 0;
|=>cur_branch:
| add rax, 1
| cmp rax, 10
| jl =>cur_branch
```

### Macros and Templating

DynASM also supports macros in a manner very similar to other languages: the contents of the macro are pasted wholesale into the location it's invoked from, with the arguments replaced.

```c
|.macro example, dst, src
| addss xmm(dst), xmm(src)
|.endmacro

uint32_t s = 3, d = 4;
| example d, s
```

You can also define constants at the DynASM level (allowing their use during preprocessing):

```c
|.define EXAMPLE 5
```

In order to use these constants in normal lines of C, those lines must be specially prefixed with `||`:

```c
||someCFunction(EXAMPLE);
```