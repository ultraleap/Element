

<!DOCTYPE html>
<html class="writer-html5" lang="en" >
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>Overview &mdash; Element Documentation  documentation</title>
  

  
  <link rel="stylesheet" href="_static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
  <link rel="stylesheet" href="_static/theme.css" type="text/css" />
  <link rel="stylesheet" href="_static/theme.css" type="text/css" />
  <link rel="stylesheet" href="_static/examplecode.css" type="text/css" />

  
  
    <link rel="shortcut icon" href="_static/favicon.ico"/>
  
  
  

  
  <!--[if lt IE 9]>
    <script src="_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
    
      <script type="text/javascript" id="documentation_options" data-url_root="./" src="_static/documentation_options.js"></script>
        <script src="_static/jquery.js"></script>
        <script src="_static/underscore.js"></script>
        <script src="_static/doctools.js"></script>
        <script src="_static/language_data.js"></script>
        <script src="_static/examplecode.js"></script>
    
    <script type="text/javascript" src="_static/js/theme.js"></script>

    
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" />
    <link rel="next" title="User Guide" href="UserGuide.html" />
    <link rel="prev" title="Element Documentation" href="index.html" /> 
</head>

<body class="wy-body-for-nav">

   
  <div class="wy-grid-for-nav">
    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search"  style="background: #EA7601" >
          

          
            <a href="index.html">
          

          
            
            <img src="_static/element.png" class="logo" alt="Logo"/>
          
          </a>

          
            
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        
        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <ul class="current">
<li class="toctree-l1 current"><a class="current reference internal" href="#">Overview</a><ul>
<li class="toctree-l2"><a class="reference internal" href="#element-language">Element Language</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#lexical-conventions">Lexical Conventions</a></li>
<li class="toctree-l3"><a class="reference internal" href="#syntax">Syntax</a></li>
<li class="toctree-l3"><a class="reference internal" href="#basic-concepts">Basic Concepts</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#values">Values</a></li>
<li class="toctree-l4"><a class="reference internal" href="#expressions">Expressions</a></li>
<li class="toctree-l4"><a class="reference internal" href="#identifiers-bindings">Identifiers &amp; Bindings</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#numbers">Numbers</a></li>
<li class="toctree-l3"><a class="reference internal" href="#namespaces">Namespaces</a></li>
<li class="toctree-l3"><a class="reference internal" href="#identifier-resolution-indexing">Identifier Resolution &amp; Indexing</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#single-static-assignment-ssa">Single Static Assignment (SSA)</a></li>
<li class="toctree-l4"><a class="reference internal" href="#cyclic-expressions">Cyclic Expressions</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#functions">Functions</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#high-order-functions">High Order Functions</a></li>
<li class="toctree-l4"><a class="reference internal" href="#recursion">Recursion</a></li>
<li class="toctree-l4"><a class="reference internal" href="#captures">Captures</a></li>
<li class="toctree-l4"><a class="reference internal" href="#unidentifier">Unidentifier</a></li>
<li class="toctree-l4"><a class="reference internal" href="#type-annotations">Type Annotations</a></li>
<li class="toctree-l4"><a class="reference internal" href="#higher-order-types">Higher Order Types</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#constraints">Constraints</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#concreteness">Concreteness</a></li>
<li class="toctree-l4"><a class="reference internal" href="#any">Any</a></li>
<li class="toctree-l4"><a class="reference internal" href="#function-constraint-a-k-a-function-type-or-function-interface">Function Constraint (a.k.a. Function Type or Function Interface)</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#structures">Structures</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#structure-declarations">Structure Declarations</a></li>
<li class="toctree-l4"><a class="reference internal" href="#structure-instances">Structure Instances</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#intrinsics">Intrinsics</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#prelude">Prelude</a></li>
<li class="toctree-l2"><a class="reference internal" href="#host-environments">Host Environments</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#top-level-functions">Top-level Functions</a></li>
<li class="toctree-l3"><a class="reference internal" href="#compilation">Compilation</a></li>
<li class="toctree-l3"><a class="reference internal" href="#data-boundary">Data Boundary</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#serialization">Serialization</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="UserGuide.html">User Guide</a></li>
<li class="toctree-l1"><a class="reference internal" href="element_dotnet/Overview.html">Element.NET Reference (C#)</a></li>
<li class="toctree-l1"><a class="reference internal" href="libelement/Overview.html">libelement Reference (C++)</a></li>
</ul>

            
          
        </div>
        
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="index.html">Element Documentation</a>
        
      </nav>


      <div class="wy-nav-content">
        
        <div class="rst-content">
        
          















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="index.html" class="icon icon-home"></a> &raquo;</li>
        
      <li>Overview</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
            
            <a href="_sources/Overview.rst.txt" rel="nofollow"> View page source</a>
          
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <div class="section" id="overview">
<h1>Overview<a class="headerlink" href="#overview" title="Permalink to this headline">Â¶</a></h1>
<p>Element is a minimal embeddable programming language designed as a data
format for writing algorithms. It is (sometimes purely) functional and
statically type checked.</p>
<p>Its primary goals are:</p>
<ul class="simple">
<li><p><strong>Portability</strong>. Designed to be parsed, compiled and executed by many different hosting environments.</p></li>
<li><p><strong>Simplicity</strong>. Syntax and semantics are simple but practical - achieving portability is easy.</p></li>
<li><p><strong>Visualizability</strong>. Designed to interact with visual editing tools.</p></li>
<li><p><strong>Guarantees</strong>:</p>
<ul>
<li><p><strong>Fixed memory usage</strong>.</p>
<ul>
<li><p>No dynamic allocation so memory usage is constant and calculable.</p></li>
<li><p>Note that memory management is implementation defined.</p></li>
</ul>
</li>
<li><p><strong>No runtime errors</strong>.</p>
<ul>
<li><p>Compiled Element will run to completion and produce a result (assuming the host is well-formed and the function halts).</p></li>
</ul>
</li>
<li><p><strong>Halting</strong>. (Except when using <code class="docutils literal notranslate"><span class="pre">for</span></code> with non-constant exit condition)</p>
<ul>
<li><p>Element is guaranteed to execute in a predictable time and take a fixed amount of resources.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">for</span></code> introduces dynamic loops and hence the halting problem.</p></li>
</ul>
</li>
<li><p><strong>Pure</strong>. (Except when using <code class="docutils literal notranslate"><span class="pre">persist</span></code>)</p>
<ul>
<li><p>Element is stateless and causes no side effects. The result is referential transparency: the same inputs will always provide the same outputs.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">persist</span></code> introduces persistent state between function executions and hence the same inputs could produce different output.</p></li>
</ul>
</li>
</ul>
</li>
</ul>
<p>As an embeddable language, Element code requires a hosting environment
to do anything useful with. The job of a host is to provide capabilities
for parsing, analysing and subsequently compiling or evaluating Element
functions.</p>
<p>Element has multiple host implementations:</p>
<table class="docutils align-default">
<colgroup>
<col style="width: 10%" />
<col style="width: 8%" />
<col style="width: 71%" />
<col style="width: 10%" />
</colgroup>
<thead>
<tr class="row-odd"><th class="head"><p>Name</p></th>
<th class="head"><p>Language</p></th>
<th class="head"><p>Evaluation</p></th>
<th class="head"><p>Compilation</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>Element.NET</p></td>
<td><p>C#</p></td>
<td><p><a class="reference external" href="https://docs.microsoft.com/en-us/dotnet/api/system.linq.expressions.expression">LINQ.Expressions</a></p></td>
<td><p>Bytecode, C</p></td>
</tr>
<tr class="row-odd"><td><p>libelement</p></td>
<td><p>C++</p></td>
<td><p>Supported</p></td>
<td><ul class="simple">
<li></li>
</ul>
</td>
</tr>
<tr class="row-even"><td><p>PyElement</p></td>
<td><p>Python</p></td>
<td><p><a class="reference external" href="https://docs.python.org/3/library/functions.html#eval">eval()</a></p></td>
<td><ul class="simple">
<li></li>
</ul>
</td>
</tr>
</tbody>
</table>
<div class="section" id="element-language">
<h2>Element Language<a class="headerlink" href="#element-language" title="Permalink to this headline">Â¶</a></h2>
<div class="section" id="lexical-conventions">
<h3>Lexical Conventions<a class="headerlink" href="#lexical-conventions" title="Permalink to this headline">Â¶</a></h3>
<p>Element code is expected to be encoded in UTF-8.</p>
<p>Element ignores whitespace, line endings and comments between tokens.</p>
<p>Comments are delimited by <code class="docutils literal notranslate"><span class="pre">#</span></code> until the end of line and are stripped
during preprocessing.</p>
<p>Identifiers are used to name expressions, functions and types.
Identifiers can be any string of letters, digits and underscores, not
starting with a digit and excluding reserved identifiers. Identifiers
are case-sensitive however reserved identifiers exclude mixed case, e.g.
<code class="docutils literal notranslate"><span class="pre">intrinsic</span></code> is reserved thus <code class="docutils literal notranslate"><span class="pre">InTrInSiC</span></code> is considered invalid.</p>
<p>Reserved identifiers:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="n">_</span>
<span class="n">intrinsic</span>
<span class="k">namespace</span>
<span class="k">return</span>
<span class="k">struct</span>
</pre></div>
</div>
<p><code class="docutils literal notranslate"><span class="pre">struct</span></code> identifiers are also reserved within their local scope.
Nested scopes in structs do not have this restriction and will shadow
the constructor although doing so is not recommended.</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="k">struct</span> <span class="nc">MyStruct</span>
<span class="p">{</span>
    <span class="cp"># Invalid, MyStruct is reserved</span>
    <span class="n">MyStruct</span> <span class="o">=</span> <span class="mi">5</span><span class="p">;</span>
    <span class="k">namespace</span> <span class="n">MySpace</span>
    <span class="p">{</span>
        <span class="cp"># Valid but not recommended as this will shadow the MyStruct constructor</span>
        <span class="n">MyStruct</span> <span class="o">=</span> <span class="mi">10</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
</div>
<div class="section" id="syntax">
<h3>Syntax<a class="headerlink" href="#syntax" title="Permalink to this headline">Â¶</a></h3>
<p>A complete description of Elementâs syntax in .ebnf form can be found
<a class="reference external" href="../Common/Grammar.ebnf">here</a>. The ebnf does not include terminals
for whitespace or comments. Hosts may deal with these however they wish
provided the language grammar remains intact.</p>
<p>The grammar is not an exact specification of valid Element code. For
example, reserved keywords are not mentioned in the grammar. Hosts are
expected to validate syntax elements after parsing to discover and
report these errors.</p>
</div>
<div class="section" id="basic-concepts">
<h3>Basic Concepts<a class="headerlink" href="#basic-concepts" title="Permalink to this headline">Â¶</a></h3>
<div class="section" id="values">
<h4>Values<a class="headerlink" href="#values" title="Permalink to this headline">Â¶</a></h4>
<p>A value is the basic unit of an Element program. Values can be declared
using language constructs or returned as the result of expressions.
Values can have one or many of the following characteristics in Element:</p>
<ul class="simple">
<li><p><strong>Indexable</strong> - can contain other values accessible via <code class="docutils literal notranslate"><span class="pre">.</span></code>, e.g. <code class="docutils literal notranslate"><span class="pre">foo</span></code> where <code class="docutils literal notranslate"><span class="pre">foo.bar</span></code> is valid.</p></li>
<li><p><strong>Callable</strong> - can produce other values through parametrization, e.g. <code class="docutils literal notranslate"><span class="pre">foo</span></code> where <code class="docutils literal notranslate"><span class="pre">foo(parameter)</span></code> is valid.</p></li>
<li><p><strong>Constraint</strong> - can accept or reject other values based on some predicate, e.g. <code class="docutils literal notranslate"><span class="pre">Any</span></code> which accepts any value or <code class="docutils literal notranslate"><span class="pre">Num</span></code> which accepts only numbers.</p></li>
<li><p><strong>Serializable</strong> - can be dealt with at the host boundary.</p></li>
</ul>
<p>The kinds of values found in Element:</p>
<table class="docutils align-default">
<colgroup>
<col style="width: 9%" />
<col style="width: 4%" />
<col style="width: 4%" />
<col style="width: 5%" />
<col style="width: 5%" />
<col style="width: 15%" />
<col style="width: 58%" />
</colgroup>
<thead>
<tr class="row-odd"><th class="head"><p>Name</p></th>
<th class="head"><p>Indexable</p></th>
<th class="head"><p>Callable</p></th>
<th class="head"><p>Constraint</p></th>
<th class="head"><p>Serializable</p></th>
<th class="head"><p>Example</p></th>
<th class="head"><p>Note</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">Num</span></code></p></td>
<td><p>Yes</p></td>
<td><ul class="simple">
<li></li>
</ul>
</td>
<td><p>Yes</p></td>
<td><p>Yes</p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">3.14159</span></code></p></td>
<td><p>Number literals behave the same as <code class="docutils literal notranslate"><span class="pre">struct</span></code> instances and can be indexed to access <code class="docutils literal notranslate"><span class="pre">Num</span></code> instance functions</p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">Any</span></code></p></td>
<td><ul class="simple">
<li></li>
</ul>
</td>
<td><ul class="simple">
<li></li>
</ul>
</td>
<td><p>Yes</p></td>
<td><ul class="simple">
<li></li>
</ul>
</td>
<td><ul class="simple">
<li></li>
</ul>
</td>
<td><p>Any is purely a Constraint and cannot have instances</p></td>
</tr>
<tr class="row-even"><td><p>Function constraint</p></td>
<td><ul class="simple">
<li></li>
</ul>
</td>
<td><ul class="simple">
<li></li>
</ul>
</td>
<td><p>Yes</p></td>
<td><ul class="simple">
<li></li>
</ul>
</td>
<td><p><code class="docutils literal notranslate"><span class="pre">constraint</span> <span class="pre">Predicate(a):Bool;</span></code></p></td>
<td><p>^</p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">struct</span></code> declaration</p></td>
<td><p>Yes</p></td>
<td><p>Yes</p></td>
<td><p>Yes</p></td>
<td><ul class="simple">
<li></li>
</ul>
</td>
<td><p><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">Vector3(x:Num,</span> <span class="pre">y:Num,</span> <span class="pre">z:Num);</span></code></p></td>
<td><p>Calling a struct creates an instance</p></td>
</tr>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">struct</span></code> instance</p></td>
<td><p>Yes</p></td>
<td><ul class="simple">
<li></li>
</ul>
</td>
<td><ul class="simple">
<li></li>
</ul>
</td>
<td><p>Maybe</p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">a</span> <span class="pre">=</span> <span class="pre">Vector3(3,</span> <span class="pre">6,</span> <span class="pre">9);</span></code></p></td>
<td><p>Can Index fields and instance functions, Serializable when all fields are, additionally List instances are Serializable when the Indexer only accesses Serializable elements</p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">namespace</span></code></p></td>
<td><p>Yes</p></td>
<td><ul class="simple">
<li></li>
</ul>
</td>
<td><ul class="simple">
<li></li>
</ul>
</td>
<td><ul class="simple">
<li></li>
</ul>
</td>
<td><p><code class="docutils literal notranslate"><span class="pre">namespace</span> <span class="pre">MySpace</span> <span class="pre">{</span> <span class="pre">...</span> <span class="pre">}</span></code></p></td>
<td><ul class="simple">
<li></li>
</ul>
</td>
</tr>
<tr class="row-even"><td><p>Constant function</p></td>
<td><ul class="simple">
<li></li>
</ul>
</td>
<td><ul class="simple">
<li></li>
</ul>
</td>
<td><ul class="simple">
<li></li>
</ul>
</td>
<td><p>Maybe</p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">tau</span> <span class="pre">=</span> <span class="pre">pi.mul(2);</span></code></p></td>
<td><p>A function with no inputs and its result are equivalent - Serializability depends on the return value</p></td>
</tr>
<tr class="row-odd"><td><p>Parameterized function</p></td>
<td><ul class="simple">
<li></li>
</ul>
</td>
<td><p>Yes</p></td>
<td><ul class="simple">
<li></li>
</ul>
</td>
<td><ul class="simple">
<li></li>
</ul>
</td>
<td><p><code class="docutils literal notranslate"><span class="pre">sqr(a:Num):Num</span> <span class="pre">=</span> <span class="pre">a.mul(a);</span></code></p></td>
<td><ul class="simple">
<li></li>
</ul>
</td>
</tr>
<tr class="row-even"><td><p>Lambda function</p></td>
<td><ul class="simple">
<li></li>
</ul>
</td>
<td><p>Yes</p></td>
<td><ul class="simple">
<li></li>
</ul>
</td>
<td><ul class="simple">
<li></li>
</ul>
</td>
<td><p><code class="docutils literal notranslate"><span class="pre">_(_):List</span> <span class="pre">=</span> <span class="pre">5;</span></code></p></td>
<td><ul class="simple">
<li></li>
</ul>
</td>
</tr>
</tbody>
</table>
</div>
<div class="section" id="expressions">
<h4>Expressions<a class="headerlink" href="#expressions" title="Permalink to this headline">Â¶</a></h4>
<p>Expressions are used build behaviour in Element. Expressions are
composable and can reference other values or contain many expressions.
An expression may be:</p>
<ul class="simple">
<li><p>a <code class="docutils literal notranslate"><span class="pre">Num</span></code> literal, e.g. <code class="docutils literal notranslate"><span class="pre">5</span></code></p></li>
<li><p>a call expression (a.k.a. function application), e.g. <code class="docutils literal notranslate"><span class="pre">add(1)</span></code></p></li>
<li><p>an indexing expression, e.g. <code class="docutils literal notranslate"><span class="pre">vector.x</span></code></p></li>
<li><p>a lambda, e.g. <code class="docutils literal notranslate"><span class="pre">_(a,</span> <span class="pre">b)</span> <span class="pre">=</span> <span class="pre">a.add(b)</span></code></p></li>
<li><p>an expression list involving many expressions, e.g. <code class="docutils literal notranslate"><span class="pre">radians.mul(180.div(Num.pi))</span></code></p></li>
</ul>
<p>The difference between an expression and a value is that expressions
are not values themselves, they define/produce values. Some expressions
define values directly:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">5</span></code> defines a <code class="docutils literal notranslate"><span class="pre">Num</span></code> value</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">_(a,</span> <span class="pre">b)</span> <span class="pre">=</span> <span class="pre">a.add(b)</span></code> defines a function</p></li>
</ul>
<p>Other expressions produce values:
- Call expressions compute new values based on input
- Indexing expressions reference existing values from elsewhere</p>
</div>
<div class="section" id="identifiers-bindings">
<h4>Identifiers &amp; Bindings<a class="headerlink" href="#identifiers-bindings" title="Permalink to this headline">Â¶</a></h4>
<p>An identifier is a name given to a value to allow referencing it in
expressions. Not all values have identifiers (e.g. a lambda), values
without identifiers are only referenced in the location they are
defined.</p>
<p>Binding is the process of assigning a value to an identifier using <code class="docutils literal notranslate"><span class="pre">=</span></code>
to reuse in more complex expressions.</p>
<p>Identifiers are shorthand for their bound expression and are substituted
for the expression during compilation (formally called beta reduction).</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="cp"># binds x to a literal value of 5</span>
<span class="n">x</span> <span class="o">=</span> <span class="mi">5</span><span class="p">;</span>

<span class="cp"># binds y to the add function call&#39;s return value</span>
<span class="n">y</span> <span class="o">=</span> <span class="n">x</span><span class="p">.</span><span class="n">add</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>

<span class="cp"># binds z to an expression list involving nested expressions which converts radians to degrees</span>
<span class="n">z</span> <span class="o">=</span> <span class="n">radians</span><span class="p">.</span><span class="n">mul</span><span class="p">(</span><span class="mf">180.</span><span class="n">div</span><span class="p">(</span><span class="n">Num</span><span class="p">.</span><span class="n">pi</span><span class="p">));</span>
</pre></div>
</div>
<p>Note that binding an expression does not directly cause a compiler to
generate instructions for storing its value. When performing analysis a
host will optimize away all non-intrinsic bindings leaving only those
which require storage instructions. This is what makes Element
declarative rather than imperative - bindings express to the compiler
what is desired rather than exactly what to do.</p>
</div>
</div>
<div class="section" id="numbers">
<h3>Numbers<a class="headerlink" href="#numbers" title="Permalink to this headline">Â¶</a></h3>
<p><code class="docutils literal notranslate"><span class="pre">Num</span></code> is the only primitive data type in Element, representing real
numbers.</p>
<p><code class="docutils literal notranslate"><span class="pre">Num</span></code> values are:</p>
<ul class="simple">
<li><p>Indexable - <code class="docutils literal notranslate"><span class="pre">Num</span></code> has no fields but does have instance functions defined on the <code class="docutils literal notranslate"><span class="pre">struct</span></code> declaration for <code class="docutils literal notranslate"><span class="pre">Num</span></code>.</p></li>
<li><p>Constraints - <code class="docutils literal notranslate"><span class="pre">Num</span></code> is a concrete Constraint which can be used to require that a value be a number.</p></li>
<li><p>Serializable - numbers are plain data and can be serialized across the host boundary.</p></li>
</ul>
<p>Numbers are definable as literals or returned as a result from a <code class="docutils literal notranslate"><span class="pre">Num</span></code>
expression. Literal number values can be declared in the following
forms:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="n">integer</span> <span class="nl">notation</span><span class="p">:</span>     <span class="mi">0</span>        <span class="mi">5</span>        <span class="mi">-10</span>        <span class="o">+</span><span class="mi">15</span>
<span class="n">rational</span> <span class="nl">notation</span><span class="p">:</span>    <span class="mf">0.0</span>      <span class="mf">5.2</span>      <span class="mf">-10.86</span>     <span class="o">+</span><span class="mf">3.14159</span>
<span class="n">e</span> <span class="nl">notation</span><span class="p">:</span>           <span class="mf">1e0</span>      <span class="mf">3E-5</span>     <span class="mf">-8e7</span>       <span class="o">+</span><span class="mf">2.998E8</span>

<span class="n">a</span> <span class="o">=</span> <span class="mf">1e5</span><span class="p">;</span>
<span class="n">b</span> <span class="o">=</span> <span class="n">a</span><span class="p">.</span><span class="n">add</span><span class="p">(</span><span class="o">+</span><span class="mf">10.3</span><span class="p">).</span><span class="n">mul</span><span class="p">(</span><span class="mi">-5</span><span class="p">);</span>
</pre></div>
</div>
<p>Many intrinsic functions are constrained to operate on numbers:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span>add(a:Num, b:Num):Num; # Performs addition
sub(a:Num, b:Num):Num; # Performs subtraction
div(a:Num, b:Num):Num; # Performs division
mul(a:Num, b:Num):Num; # Performs multiplication
</pre></div>
</div>
</div>
<div class="section" id="namespaces">
<h3>Namespaces<a class="headerlink" href="#namespaces" title="Permalink to this headline">Â¶</a></h3>
<p>A namespace is a value containing other values which can be accessed via
Indexing.</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="k">namespace</span> <span class="n">Foo</span>
<span class="p">{</span>
    <span class="n">x</span> <span class="o">=</span> <span class="mi">10</span><span class="p">;</span>
<span class="p">}</span>

<span class="cp"># Indexes into Foo to retrieve x, resolving to 10</span>
<span class="n">a</span> <span class="o">=</span> <span class="n">Foo</span><span class="p">.</span><span class="n">x</span><span class="p">;</span>
</pre></div>
</div>
</div>
<div class="section" id="identifier-resolution-indexing">
<h3>Identifier Resolution &amp; Indexing<a class="headerlink" href="#identifier-resolution-indexing" title="Permalink to this headline">Â¶</a></h3>
<p>Identifiers refer to the value they are bound to. When referencing an
identifier, the value is resolved using identifier resolution rules.</p>
<p>Identifiers are defined within scopes - scopes are nestable collections
of identifiers defined by several language constructs such as
namespaces. Expressions can access identifiers defined in outer scopes
implicitly. The root scope is known as the global scope as its
identifiers can be accessed from anywhere.</p>
<p>Identifier resolution rules are as follows:</p>
<ol class="arabic simple">
<li><p>Local identifiers in scope containing the expression being resolved</p></li>
<li><p>Function arguments when in a functionâs scope</p></li>
<li><p>Outer scoped identifiers, repeating 1 and 2 recursively until global scope</p></li>
</ol>
<p>Identifier resolution is distinct from Indexing. Indexing is an
expression <code class="docutils literal notranslate"><span class="pre">.</span></code> for accessing contents of a value - values have their
own Indexing rules.</p>
<p>Note that this is distinct from many other languages which have scoped
identifiers. In Element, <code class="docutils literal notranslate"><span class="pre">Foo.Bar</span></code> resolves <code class="docutils literal notranslate"><span class="pre">Foo</span></code> using identifier
resolution and <code class="docutils literal notranslate"><span class="pre">.Bar</span></code> by Indexing the value identified by <code class="docutils literal notranslate"><span class="pre">Foo</span></code>. If
<code class="docutils literal notranslate"><span class="pre">Foo</span></code> fails to identify a value, the expression is invalid.</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="n">x</span> <span class="o">=</span> <span class="mi">5</span><span class="p">;</span>
<span class="k">namespace</span> <span class="n">Foo</span>
<span class="p">{</span>
    <span class="n">y</span> <span class="o">=</span> <span class="mi">10</span><span class="p">;</span>
    <span class="k">namespace</span> <span class="n">Bar</span>
    <span class="p">{</span>
        <span class="n">x</span> <span class="o">=</span> <span class="mi">15</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="cp"># Does not identify a local x within Foo, recurses to global scope and finds x, resolving to 5</span>
    <span class="n">a</span> <span class="o">=</span> <span class="n">x</span><span class="p">;</span>

    <span class="cp"># Immediately identifies the Bar defined in Foo, indexing x within it, resolving to 15</span>
    <span class="n">b</span> <span class="o">=</span> <span class="n">Bar</span><span class="p">.</span><span class="n">x</span><span class="p">;</span>

    <span class="cp"># Error, indentifies local Bar but indexing a nested y within fails</span>
    <span class="n">c</span> <span class="o">=</span> <span class="n">Bar</span><span class="p">.</span><span class="n">y</span><span class="p">;</span>

    <span class="cp"># Identifies y locally, resolving to 10</span>
    <span class="n">d</span> <span class="o">=</span> <span class="n">y</span><span class="p">;</span>

    <span class="cp"># No local Foo, recurses to the global scope and identifies Foo, indexing it to find y, resolving to 10</span>
    <span class="n">e</span> <span class="o">=</span> <span class="n">Foo</span><span class="p">.</span><span class="n">y</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<div class="section" id="single-static-assignment-ssa">
<h4>Single Static Assignment (SSA)<a class="headerlink" href="#single-static-assignment-ssa" title="Permalink to this headline">Â¶</a></h4>
<p>Element uses single static assignment (SSA): identifiers are immutable
and unique in each scope. If <code class="docutils literal notranslate"><span class="pre">x</span></code> is defined as <code class="docutils literal notranslate"><span class="pre">5</span></code>, it cannot be
rebound to <code class="docutils literal notranslate"><span class="pre">6</span></code> within the same scope. A consequence of this is that
the order expressions are defined doesnât matter. SSA does not disallow
shadowing, the same identifier may be defined in different scopes.</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="n">x</span> <span class="o">=</span> <span class="mi">5</span><span class="p">;</span>
<span class="k">namespace</span> <span class="n">Outer</span>
<span class="p">{</span>
    <span class="cp"># Refers to the global x since x is not defined in Outer</span>
    <span class="n">y</span> <span class="o">=</span> <span class="n">x</span><span class="p">.</span><span class="n">add</span><span class="p">(</span><span class="mi">5</span><span class="p">);</span>
    <span class="k">namespace</span> <span class="n">Inner</span>
    <span class="p">{</span>
        <span class="cp"># Refers to global x and Outer.y</span>
        <span class="cp"># Shadows z defined in Outer, references to z in this scope or nested scopes will use this z</span>
        <span class="n">z</span> <span class="o">=</span> <span class="n">x</span><span class="p">.</span><span class="n">add</span><span class="p">(</span><span class="n">y</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="cp"># Valid as global x and Outer.x are unique</span>
    <span class="n">x</span> <span class="o">=</span> <span class="mi">5</span><span class="p">;</span>

    <span class="cp"># This is invalid, y is already defined in Outer</span>
    <span class="n">y</span> <span class="o">=</span> <span class="mi">10</span><span class="p">;</span>

    <span class="cp"># Valid as Outer.z and Outer.Inner.z are unique</span>
    <span class="n">z</span> <span class="o">=</span> <span class="n">x</span><span class="p">.</span><span class="n">add</span><span class="p">(</span><span class="n">y</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
</div>
<p>Since all bindings are immutable we deliberately avoid using the term
<code class="docutils literal notranslate"><span class="pre">variable</span></code> to describe them.</p>
</div>
<div class="section" id="cyclic-expressions">
<h4>Cyclic Expressions<a class="headerlink" href="#cyclic-expressions" title="Permalink to this headline">Â¶</a></h4>
<p>It is syntactically possible to define cyclic expressions that reference
themselves since definition order doesnât matter. Expressions must be
acyclic, cyclic expressions (directly or indirectly caused) are illegal.
For explicit looping, the <code class="docutils literal notranslate"><span class="pre">for</span></code> intrinsic is available.</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="cp"># Directly cyclic expression - a depends on itself, causing an infinite cycle</span>
<span class="n">a</span> <span class="o">=</span> <span class="n">a</span><span class="p">.</span><span class="n">add</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>

<span class="cp"># Indirectly cyclic expressions - b and c depend on each other, causing an infinite cycle</span>
<span class="n">b</span> <span class="o">=</span> <span class="n">c</span><span class="p">.</span><span class="n">add</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
<span class="n">c</span> <span class="o">=</span> <span class="n">b</span><span class="p">.</span><span class="n">add</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
</pre></div>
</div>
</div>
</div>
<div class="section" id="functions">
<h3>Functions<a class="headerlink" href="#functions" title="Permalink to this headline">Â¶</a></h3>
<p>Functions are Callable values which return a value when parameterized by
one or more other expressions. Functions are syntactically defined by 2
components, their interface (or declaration) and their function body.</p>
<p>A functionâs interface includes a parameter list and a return type. The
function body defines one or many expressions which relate the
parameters to the return value.</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="cp"># degrees is a function that coverts radians to degrees</span>
<span class="n">degrees</span><span class="p">(</span><span class="n">radians</span><span class="p">)</span> <span class="o">=</span> <span class="n">radians</span><span class="p">.</span><span class="n">mul</span><span class="p">(</span><span class="mf">180.</span><span class="n">div</span><span class="p">(</span><span class="n">Num</span><span class="p">.</span><span class="n">pi</span><span class="p">));</span>

<span class="cp"># lerp is a function that performs linear interpolation, returning t amount along a to b</span>
<span class="n">lerp</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">)</span> <span class="o">=</span> <span class="n">a</span><span class="p">.</span><span class="n">add</span><span class="p">(</span><span class="n">t</span><span class="p">.</span><span class="n">mul</span><span class="p">(</span><span class="n">b</span><span class="p">.</span><span class="n">sub</span><span class="p">(</span><span class="n">a</span><span class="p">)));</span>
</pre></div>
</div>
<p>Calling functions binds the resulting value, these locations are known
as call sites.</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="cp"># binds deg to pi radians, resulting in 180</span>
<span class="n">deg</span> <span class="o">=</span> <span class="n">degrees</span><span class="p">(</span><span class="n">Num</span><span class="p">.</span><span class="n">pi</span><span class="p">);</span>
</pre></div>
</div>
<p>Functions can define a scope to declare intermediate expressions for
calculating the result. In a function scope the result must be bound to
a <code class="docutils literal notranslate"><span class="pre">return</span></code> identifier.</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="cp"># mod is the Modulo function, returning the remainder rounded towards negative infinity</span>
<span class="n">mod</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">)</span>
<span class="p">{</span>
    <span class="cp"># c is referenced multiple times in the return expression</span>
    <span class="cp"># thus it is helpful to define it once instead of repeating</span>
    <span class="n">c</span> <span class="o">=</span> <span class="n">a</span><span class="p">.</span><span class="n">rem</span><span class="p">(</span><span class="n">b</span><span class="p">);</span>
    <span class="k">return</span> <span class="o">=</span> <span class="n">c</span><span class="p">.</span><span class="n">mul</span><span class="p">(</span><span class="n">b</span><span class="p">).</span><span class="n">lt</span><span class="p">(</span><span class="mi">0</span><span class="p">).</span><span class="k">if</span><span class="p">(</span><span class="n">add</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">b</span><span class="p">),</span> <span class="n">c</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
</div>
<p>Function scopes cannot be Indexed externally, their values are hidden as
implementation details. The only way to return a value from a function
is via its result.</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="cp"># Error, mod is a function which can only be called or referenced in an expression</span>
<span class="n">a</span> <span class="o">=</span> <span class="n">mod</span><span class="p">.</span><span class="n">c</span><span class="p">;</span>

<span class="cp"># Error, calling mod results in a number which does not contain value c when indexed</span>
<span class="n">b</span> <span class="o">=</span> <span class="mf">5.</span><span class="n">mod</span><span class="p">(</span><span class="mi">4</span><span class="p">).</span><span class="n">c</span><span class="p">;</span>
</pre></div>
</div>
<p>As with other identifiers, function identifiers must be unique, function
overloading is disallowed.</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="cp"># Valid, foo is bound and identifies a function with 2 parameters</span>
<span class="n">foo</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">)</span> <span class="o">=</span> <span class="p">...;</span>

<span class="cp"># Error, foo is already a bound identifier in this scope</span>
<span class="n">foo</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">c</span><span class="p">)</span> <span class="o">=</span> <span class="p">...;</span>
</pre></div>
</div>
<div class="section" id="high-order-functions">
<h4>High Order Functions<a class="headerlink" href="#high-order-functions" title="Permalink to this headline">Â¶</a></h4>
<p>Functions are first-class values and can be passed into and returned
from other functions like any other value.</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="cp"># Calls the input function twice on the input value</span>
<span class="n">applyTwice</span><span class="p">(</span><span class="n">function</span><span class="p">,</span> <span class="n">value</span><span class="p">)</span> <span class="o">=</span> <span class="n">function</span><span class="p">(</span><span class="n">function</span><span class="p">(</span><span class="n">value</span><span class="p">));</span>

<span class="cp"># Returns a function defined locally within another function</span>
<span class="n">makeAdder</span><span class="p">(</span><span class="n">amountToAdd</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">return</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">amountToAdd</span><span class="p">)</span> <span class="o">=</span> <span class="n">a</span><span class="p">.</span><span class="n">add</span><span class="p">(</span><span class="n">amountToAdd</span><span class="p">);</span>
<span class="p">}</span>

<span class="cp"># Partial application - binds halfAlong to 0.5 way between min and max</span>
<span class="n">halfAlong</span><span class="p">(</span><span class="n">min</span><span class="p">,</span> <span class="n">max</span><span class="p">)</span> <span class="o">=</span> <span class="n">lerp</span><span class="p">(</span><span class="mf">0.5</span><span class="p">,</span> <span class="n">min</span><span class="p">,</span> <span class="n">max</span><span class="p">);</span>
<span class="cp"># resolves a to 15</span>
<span class="n">a</span> <span class="o">=</span> <span class="n">halfAlong</span><span class="p">(</span><span class="mi">10</span><span class="p">,</span> <span class="mi">20</span><span class="p">);</span>
</pre></div>
</div>
</div>
<div class="section" id="recursion">
<h4>Recursion<a class="headerlink" href="#recursion" title="Permalink to this headline">Â¶</a></h4>
<p>Since cyclic references are illegal, recursion is also disallowed. A
function may not reference itself directly or indirectly. Iteration is
available as an alternative via the <code class="docutils literal notranslate"><span class="pre">for</span></code> intrinsic.</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="n">factorial</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">body</span><span class="p">(</span><span class="n">t</span><span class="p">)</span> <span class="o">=</span> <span class="n">Tuple</span><span class="p">(</span><span class="n">t</span><span class="p">.</span><span class="n">item1</span><span class="p">.</span><span class="n">add</span><span class="p">(</span><span class="mi">1</span><span class="p">),</span> <span class="n">v</span><span class="p">.</span><span class="n">item2</span><span class="p">.</span><span class="n">mul</span><span class="p">(</span><span class="n">v</span><span class="p">.</span><span class="n">item1</span><span class="p">));</span>
    <span class="k">return</span> <span class="o">=</span> <span class="k">for</span><span class="p">(</span><span class="n">Tuple</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span> <span class="n">_</span><span class="p">(</span><span class="n">t</span><span class="p">)</span> <span class="o">=</span> <span class="n">leq</span><span class="p">(</span><span class="n">t</span><span class="p">.</span><span class="n">item1</span><span class="p">,</span> <span class="n">a</span><span class="p">),</span> <span class="n">body</span><span class="p">).</span><span class="n">item2</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
</div>
<div class="section" id="captures">
<h4>Captures<a class="headerlink" href="#captures" title="Permalink to this headline">Â¶</a></h4>
<p>A function scope can contain any other values, e.g. other functions.</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="n">scaleAndSumNumbers</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">c</span><span class="p">,</span> <span class="n">scale</span><span class="p">)</span>
<span class="p">{</span>
    <span class="cp"># doScale is defined only within scaleAndSumNumbers</span>
    <span class="n">doScale</span><span class="p">(</span><span class="n">number</span><span class="p">)</span> <span class="o">=</span> <span class="n">number</span><span class="p">.</span><span class="n">mul</span><span class="p">(</span><span class="n">scale</span><span class="p">);</span>
    <span class="n">sa</span> <span class="o">=</span> <span class="n">doScale</span><span class="p">(</span><span class="n">a</span><span class="p">);</span>
    <span class="n">sb</span> <span class="o">=</span> <span class="n">doScale</span><span class="p">(</span><span class="n">b</span><span class="p">);</span>
    <span class="n">sc</span> <span class="o">=</span> <span class="n">doScale</span><span class="p">(</span><span class="n">c</span><span class="p">);</span>
    <span class="k">return</span> <span class="o">=</span> <span class="n">sa</span><span class="p">.</span><span class="n">add</span><span class="p">(</span><span class="n">sb</span><span class="p">.</span><span class="n">add</span><span class="p">(</span><span class="n">sc</span><span class="p">));</span>
<span class="p">}</span>
</pre></div>
</div>
<p>When defining a nested value within a function, the nested value may
depend on values which are part of the outer function. When these nested
values directly or indirectly depend on input of the outer function then
they are âcapturedâ when the nested value is passed around or returned.</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="cp"># value is captured by the Indexer in the returned List</span>
<span class="n">repeat</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="n">count</span><span class="p">)</span> <span class="o">=</span> <span class="n">List</span><span class="p">(</span><span class="n">_</span><span class="p">(</span><span class="n">_</span><span class="p">)</span> <span class="o">=</span> <span class="n">value</span><span class="p">,</span> <span class="n">count</span><span class="p">);</span>

<span class="cp"># the return type of myFunction is &quot;struct Voldemort&quot;</span>
<span class="cp"># but this type is inaccessible from outside of myFunction</span>
<span class="cp"># Voldemort&#39;s struct declaration is captured by type instance</span>
<span class="n">myFunction</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">struct</span> <span class="nf">Voldemort</span><span class="p">(</span><span class="n">u</span><span class="p">,</span> <span class="n">v</span><span class="p">);</span>
    <span class="k">return</span> <span class="o">=</span> <span class="n">Voldemort</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
</div>
</div>
<div class="section" id="unidentifier">
<h4>Unidentifier<a class="headerlink" href="#unidentifier" title="Permalink to this headline">Â¶</a></h4>
<p>It is sometimes useful to avoid binding an identifier for an expression
when it is unused or only required once. In these cases the unidentifier
<code class="docutils literal notranslate"><span class="pre">_</span></code> can be used:</p>
<p>Lambdas (anonymous/unidentified functions) - relevant when defining
single-use functions within another expression</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="cp"># binds an unidentified function to the last argument of fold</span>
<span class="cp"># sum is all array elements added together</span>
<span class="n">sum</span> <span class="o">=</span> <span class="n">array</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">).</span><span class="n">fold</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">_</span><span class="p">(</span><span class="n">accum</span><span class="p">,</span> <span class="n">element</span><span class="p">)</span> <span class="o">=</span> <span class="n">accum</span><span class="p">.</span><span class="n">add</span><span class="p">(</span><span class="n">element</span><span class="p">));</span>

<span class="cp"># binds the lambda as the return value of the function</span>
<span class="cp"># equivalent to the makeAdder function in the High Order Functions example above</span>
<span class="n">makeAdder</span><span class="p">(</span><span class="n">amountToAdd</span><span class="p">)</span> <span class="o">=</span> <span class="n">_</span><span class="p">(</span><span class="n">a</span><span class="p">)</span> <span class="o">=</span> <span class="n">a</span><span class="p">.</span><span class="n">add</span><span class="p">(</span><span class="n">amountToAdd</span><span class="p">);</span>
</pre></div>
</div>
<p>Unused arguments - relevant when a functionâs interface demands
arguments that are unused in the body</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="n">repeat</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="n">count</span><span class="p">)</span>
<span class="p">{</span>
    <span class="cp"># For any index it returns the same value.</span>
    <span class="cp"># _ is used to intentionally ignore the index parameter</span>
    <span class="n">index</span><span class="p">(</span><span class="n">_</span><span class="p">)</span> <span class="o">=</span> <span class="n">value</span><span class="p">;</span>
    <span class="k">return</span> <span class="o">=</span> <span class="n">List</span><span class="p">(</span><span class="n">index</span><span class="p">,</span> <span class="n">count</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
</div>
</div>
<div class="section" id="type-annotations">
<h4>Type Annotations<a class="headerlink" href="#type-annotations" title="Permalink to this headline">Â¶</a></h4>
<p>Element is statically typed; all expressions have an associated type
which is checked for consistency when compiling. Types are Constraints
used to limit what values a function can accept and return. Types are
declared using <code class="docutils literal notranslate"><span class="pre">:</span></code> after a parameterâs identifier or, for return
types, after the function parameter list.</p>
<p>Type annotations are optional - when no type is given, <code class="docutils literal notranslate"><span class="pre">Any</span></code> is
implied.</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="cp"># to calls the given Unary function to turn a Num into any other type</span>
<span class="n">to</span><span class="p">(</span><span class="nl">a</span><span class="p">:</span><span class="n">Num</span><span class="p">,</span> <span class="nl">constructor</span><span class="p">:</span><span class="n">Unary</span><span class="p">)</span> <span class="o">=</span> <span class="n">constructor</span><span class="p">(</span><span class="n">a</span><span class="p">);</span>
</pre></div>
</div>
</div>
<div class="section" id="higher-order-types">
<h4>Higher Order Types<a class="headerlink" href="#higher-order-types" title="Permalink to this headline">Â¶</a></h4>
<p>Element explicitly doesnât support constraints as parameters or return
types. This would allow parameterized types - the implications of which
have not been fully considered.</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="n">List</span><span class="p">(</span><span class="n">t</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">tIndexer</span><span class="p">(</span><span class="nl">idx</span><span class="p">:</span><span class="n">Num</span><span class="p">)</span><span class="o">:</span><span class="n">t</span><span class="p">;</span>
    <span class="k">struct</span> <span class="nf">return</span><span class="p">(</span><span class="nl">at</span><span class="p">:</span><span class="n">tIndexer</span><span class="p">,</span> <span class="nl">count</span><span class="p">:</span><span class="n">Num</span><span class="p">);</span>
<span class="p">}</span>

<span class="n">sum</span><span class="p">(</span><span class="nl">a</span><span class="p">:</span><span class="n">List</span><span class="p">(</span><span class="n">Num</span><span class="p">))</span> <span class="o">=</span> <span class="n">a</span><span class="p">.</span><span class="n">fold</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="p">(</span><span class="n">accum</span><span class="p">,</span> <span class="n">element</span><span class="p">)</span> <span class="o">=</span> <span class="n">accum</span><span class="p">.</span><span class="n">add</span><span class="p">(</span><span class="n">element</span><span class="p">));</span>
</pre></div>
</div>
<p>A <a class="reference external" href="../Language/Proposals/TypeFunctions.md">proposal</a> exists for
allowing this behaviour.</p>
</div>
</div>
<div class="section" id="constraints">
<h3>Constraints<a class="headerlink" href="#constraints" title="Permalink to this headline">Â¶</a></h3>
<p>Constraints are expressions used to limit what kinds of values can be
dealt with. Constraints are used as type annotations for Callable values
and other Constraints.</p>
<div class="section" id="concreteness">
<h4>Concreteness<a class="headerlink" href="#concreteness" title="Permalink to this headline">Â¶</a></h4>
<p>Constraints can be concrete or non-concrete (polymorphic).</p>
<p>A concrete constraint is one which matches only one type of value, e.g.
<code class="docutils literal notranslate"><span class="pre">Num</span></code> or <code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">Vector3(x:Num,</span> <span class="pre">y:Num,</span> <span class="pre">z:Num);</span></code>.</p>
<p>Non-concrete constraints are polymorphic - they allow more generalized
expressions where many types of values are interchangeable, e.g. <code class="docutils literal notranslate"><span class="pre">Any</span></code>
or <code class="docutils literal notranslate"><span class="pre">Predicate(a):Bool;</span></code></p>
</div>
<div class="section" id="any">
<h4>Any<a class="headerlink" href="#any" title="Permalink to this headline">Â¶</a></h4>
<p>The <code class="docutils literal notranslate"><span class="pre">Any</span></code> constraint allows any value to be dealt with and can be
thought of as the absence of a constraint. Since this constraint is
guaranteed to pass, it is possible to write generic code where the
passed valueâs constraint is an implicit interface of all the locations
the value is referenced.</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="cp"># a is of type any</span>
<span class="cp"># call sites of even must pass a value which can Index an instance function rem(a, b:Num)</span>
<span class="cp"># which in turn must return a value which can Index an instance function eq(a, b:Num):Bool</span>
<span class="cp"># in order to pass type checking</span>
<span class="n">even</span><span class="p">(</span><span class="n">a</span><span class="p">)</span><span class="o">:</span><span class="n">Bool</span> <span class="o">=</span> <span class="n">a</span><span class="p">.</span><span class="n">rem</span><span class="p">(</span><span class="mi">2</span><span class="p">).</span><span class="n">eq</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>

<span class="cp"># Changing a to type Num requires that a be of exactly type Num</span>
<span class="cp"># This is more explicit but less flexible as there could be other types which can satisfy type checking of the generic version</span>
<span class="n">even</span><span class="p">(</span><span class="nl">a</span><span class="p">:</span><span class="n">Num</span><span class="p">)</span><span class="o">:</span><span class="n">Bool</span> <span class="o">=</span> <span class="n">a</span><span class="p">.</span><span class="n">rem</span><span class="p">(</span><span class="mi">2</span><span class="p">).</span><span class="n">eq</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
</pre></div>
</div>
</div>
<div class="section" id="function-constraint-a-k-a-function-type-or-function-interface">
<h4>Function Constraint (a.k.a. Function Type or Function Interface)<a class="headerlink" href="#function-constraint-a-k-a-function-type-or-function-interface" title="Permalink to this headline">Â¶</a></h4>
<p>Function constraints allow constraining the type of a expression to a
function with specific parameters and return.</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="cp"># Predicate is a function type taking a parameter of any type and returning a bool</span>
<span class="n">Predicate</span><span class="p">(</span><span class="n">a</span><span class="p">)</span><span class="o">:</span><span class="n">Bool</span><span class="p">;</span>

<span class="cp"># Any checks if any list elements pass the given predicate</span>
<span class="n">any</span><span class="p">(</span><span class="nl">list</span><span class="p">:</span><span class="n">List</span><span class="p">,</span> <span class="nl">pred</span><span class="p">:</span><span class="n">Predicate</span><span class="p">)</span><span class="o">:</span><span class="n">Bool</span>
    <span class="o">=</span> <span class="n">list</span><span class="p">.</span><span class="n">fold</span><span class="p">(</span><span class="n">Bool</span><span class="p">.</span><span class="nb">false</span><span class="p">,</span> <span class="n">_</span><span class="p">(</span><span class="n">accum</span><span class="p">,</span> <span class="n">element</span><span class="p">)</span> <span class="o">=</span> <span class="n">accum</span><span class="p">.</span><span class="n">or</span><span class="p">(</span><span class="n">pred</span><span class="p">(</span><span class="n">element</span><span class="p">)));</span>

<span class="cp"># The interface of even matches Predicate</span>
<span class="n">even</span><span class="p">(</span><span class="nl">a</span><span class="p">:</span><span class="n">Num</span><span class="p">)</span><span class="o">:</span><span class="n">Bool</span> <span class="o">=</span> <span class="n">a</span><span class="p">.</span><span class="n">rem</span><span class="p">(</span><span class="mi">2</span><span class="p">).</span><span class="n">eq</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>

<span class="cp"># Thus we can call any, passing the function even as an instance of Predicate</span>
<span class="n">anyEven</span> <span class="o">=</span> <span class="n">any</span><span class="p">(</span><span class="n">array</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">5</span><span class="p">),</span> <span class="n">even</span><span class="p">);</span>
<span class="cp"># anyEven evaluates to Bool.false since none of the array elements are even</span>
</pre></div>
</div>
</div>
</div>
<div class="section" id="structures">
<h3>Structures<a class="headerlink" href="#structures" title="Permalink to this headline">Â¶</a></h3>
<p>Structures are a value grouping mechanism. Structures involve 2 distinct
kinds of values, <code class="docutils literal notranslate"><span class="pre">struct</span></code> declarations and instances.</p>
<div class="section" id="structure-declarations">
<h4>Structure Declarations<a class="headerlink" href="#structure-declarations" title="Permalink to this headline">Â¶</a></h4>
<p>Structures are defined using the <code class="docutils literal notranslate"><span class="pre">struct</span></code> qualifier followed by a
parameter list defining the fields that a <code class="docutils literal notranslate"><span class="pre">struct</span></code> instance must have.</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="k">struct</span> <span class="nf">Complex</span><span class="p">(</span><span class="nl">real</span><span class="p">:</span><span class="n">Num</span><span class="p">,</span> <span class="nl">imaginary</span><span class="p">:</span><span class="n">Num</span><span class="p">);</span>
</pre></div>
</div>
<p>A fields is simply a value in a structures group. <code class="docutils literal notranslate"><span class="pre">real</span></code> and
<code class="docutils literal notranslate"><span class="pre">imaginary</span></code> are the fields for a <code class="docutils literal notranslate"><span class="pre">Complex</span></code> instance.</p>
<p><code class="docutils literal notranslate"><span class="pre">struct</span></code> declaration values are:</p>
<ul class="simple">
<li><p>Callable - as a constructor function for creating <code class="docutils literal notranslate"><span class="pre">struct</span></code> instances.</p></li>
<li><p>Indexable - <code class="docutils literal notranslate"><span class="pre">struct</span></code> declarations can contain other values in an optional scope.</p></li>
<li><p>Constraints - <code class="docutils literal notranslate"><span class="pre">struct</span></code> declarations can be used to limit values to instances of the <code class="docutils literal notranslate"><span class="pre">struct</span></code>.</p></li>
</ul>
<p>Constructors are automatically implemented by the compiler.</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="cp"># Creates a Complex instance with real number 5 and imaginary number 10</span>
<span class="n">myComplex</span> <span class="o">=</span> <span class="n">Complex</span><span class="p">(</span><span class="mi">5</span><span class="p">,</span> <span class="mi">10</span><span class="p">);</span>
</pre></div>
</div>
<p>Note that the <code class="docutils literal notranslate"><span class="pre">struct</span></code> declarationâs identifier is reserved within the
structures scope (but not nested ones).</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="k">struct</span> <span class="nf">Complex</span><span class="p">(</span><span class="nl">real</span><span class="p">:</span><span class="n">Num</span><span class="p">,</span> <span class="nl">imaginary</span><span class="p">:</span><span class="n">Num</span><span class="p">)</span>
<span class="p">{</span>
    <span class="cp"># adds two complex numbers together, resulting in another complex</span>
    <span class="cp"># the implementation must use the Complex constructor to create the result</span>
    <span class="n">add</span><span class="p">(</span><span class="nl">a</span><span class="p">:</span><span class="n">Complex</span><span class="p">,</span> <span class="nl">b</span><span class="p">:</span><span class="n">Complex</span><span class="p">)</span><span class="o">:</span><span class="n">Complex</span> <span class="o">=</span> <span class="n">Complex</span><span class="p">(</span><span class="n">a</span><span class="p">.</span><span class="n">real</span><span class="p">.</span><span class="n">add</span><span class="p">(</span><span class="n">b</span><span class="p">.</span><span class="n">real</span><span class="p">),</span> <span class="n">a</span><span class="p">.</span><span class="n">imaginary</span><span class="p">.</span><span class="n">add</span><span class="p">(</span><span class="n">b</span><span class="p">.</span><span class="n">imaginary</span><span class="p">));</span>

    <span class="cp"># invalid, Complex is reserved within the struct scope</span>
    <span class="n">Complex</span> <span class="o">=</span> <span class="mi">5</span><span class="p">;</span>

    <span class="k">namespace</span> <span class="n">Foo</span>
    <span class="p">{</span>
        <span class="cp"># valid but strongly discouraged as this will shadow the outer struct</span>
        <span class="cp"># compilers will issue a warning when this shadowing occurs</span>
        <span class="n">Complex</span> <span class="o">=</span> <span class="mi">5</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="cp"># Usage example, a and b are struct instances</span>
<span class="n">a</span> <span class="o">=</span> <span class="n">Complex</span><span class="p">(</span><span class="mi">5</span><span class="p">,</span> <span class="mi">5</span><span class="p">);</span>
<span class="n">b</span> <span class="o">=</span> <span class="n">Complex</span><span class="p">(</span><span class="mi">8</span><span class="p">,</span> <span class="mi">8</span><span class="p">);</span>

<span class="cp"># Add can be called via indexing Complex</span>
<span class="n">c</span> <span class="o">=</span> <span class="n">Complex</span><span class="p">.</span><span class="n">add</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">);</span>
</pre></div>
</div>
</div>
<div class="section" id="structure-instances">
<h4>Structure Instances<a class="headerlink" href="#structure-instances" title="Permalink to this headline">Â¶</a></h4>
<p>A <code class="docutils literal notranslate"><span class="pre">struct</span></code> instance is a value with a layout conforming to a specific
<code class="docutils literal notranslate"><span class="pre">struct</span></code> declaration.</p>
<p><code class="docutils literal notranslate"><span class="pre">struct</span></code> instances are:</p>
<ul class="simple">
<li><p>Indexable - provides access to struct members - members are fields and instance functions.</p></li>
<li><p>Serializable (sometimes) - when all fields are serializable, the instance is also serializable.</p></li>
</ul>
<div class="section" id="instance-functions">
<h5>Instance Functions<a class="headerlink" href="#instance-functions" title="Permalink to this headline">Â¶</a></h5>
<p>Instance functions are functions defined within a <code class="docutils literal notranslate"><span class="pre">struct</span></code>
declarationâs scope where:</p>
<ul class="simple">
<li><p>The first argument is the <code class="docutils literal notranslate"><span class="pre">struct</span></code> declarationâs type.</p></li>
<li><p>Instance functions are Indexable from <code class="docutils literal notranslate"><span class="pre">struct</span></code> instances.</p></li>
<li><p>Instance functions apply the first parameter as the <code class="docutils literal notranslate"><span class="pre">struct</span></code> instance being Indexed.</p></li>
</ul>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="cp"># continuing from the example above...</span>
<span class="cp"># add can be called as an instance function since it&#39;s first parameter is type Complex</span>
<span class="cp"># d is an equivalent expression to c above</span>
<span class="n">d</span> <span class="o">=</span> <span class="n">a</span><span class="p">.</span><span class="n">add</span><span class="p">(</span><span class="n">b</span><span class="p">);</span>
</pre></div>
</div>
<p>Instance function calls can be chained allowing natural expressions
which read left to right.</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="cp"># binds numbers to an array of all even numbers n..m divisible by 5.</span>
<span class="cp"># List.range is prefix called (it is a generator and can&#39;t be infix called)</span>
<span class="cp"># and then transformed by infix calling filter</span>
<span class="cp"># even is a predicate returning 1 or 0 if a number is even or not</span>
<span class="n">numbers</span> <span class="o">=</span> <span class="n">List</span><span class="p">.</span><span class="n">range</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">m</span><span class="p">)).</span><span class="n">filter</span><span class="p">(</span><span class="n">_</span><span class="p">(</span><span class="n">i</span><span class="p">)</span> <span class="o">=</span> <span class="n">even</span><span class="p">(</span><span class="n">i</span><span class="p">).</span><span class="n">and</span><span class="p">(</span><span class="n">i</span><span class="p">.</span><span class="n">rem</span><span class="p">(</span><span class="mi">5</span><span class="p">).</span><span class="n">eq</span><span class="p">(</span><span class="mi">0</span><span class="p">)));</span>
</pre></div>
</div>
</div>
</div>
</div>
<div class="section" id="intrinsics">
<h3>Intrinsics<a class="headerlink" href="#intrinsics" title="Permalink to this headline">Â¶</a></h3>
<p>Intrinsics are functions and types which hosts must explicitly support.
All Element programs are composed from intrinsics to perform tasks.
Intrinsics can be declared in source code using the <code class="docutils literal notranslate"><span class="pre">intrinsic</span></code>
keyword.</p>
<p>Intrinsics have a few special rules that differ from normal structs and
functions:</p>
<ul class="simple">
<li><p>Intrinsic functions are implemented by hosts.</p></li>
<li><p>Intrinsics can be variadic (types or functions with variable number of fields). Element does not directly support variadic functions or types however a few intrinsic constructs are variadic and can be referenced as long as their interfaces are satisfied.</p></li>
<li><p>Intrinsics may omit an interface as it may not be possible to describe in the language (due to allowing variadics).</p></li>
</ul>
</div>
</div>
<div class="section" id="prelude">
<h2>Prelude<a class="headerlink" href="#prelude" title="Permalink to this headline">Â¶</a></h2>
<p>Prelude is a base library of Element source code containing intrinsics
and values implementing core functionality. The source for Prelude can
be found <a class="reference external" href="../Common/Prelude/Prelude.ele">here</a>.</p>
<p><code class="docutils literal notranslate"><span class="pre">Bool</span></code> is an intrinsic type implemented in the Prelude. <code class="docutils literal notranslate"><span class="pre">Bool</span></code> is
not a primitive type, it is backed by a <code class="docutils literal notranslate"><span class="pre">Num</span></code>. When creating an
instance of <code class="docutils literal notranslate"><span class="pre">Bool</span></code> using the constructor the compiler must refine the
backing <code class="docutils literal notranslate"><span class="pre">Num</span></code> to 1 or 0, signifying <code class="docutils literal notranslate"><span class="pre">True</span></code> and <code class="docutils literal notranslate"><span class="pre">False</span></code>
respectively. The formula for refinement is <code class="docutils literal notranslate"><span class="pre">value</span> <span class="pre">&gt;</span> <span class="pre">0</span> <span class="pre">?</span> <span class="pre">1</span> <span class="pre">:</span> <span class="pre">0</span></code>, i.e.
positive numbers are truthy, negative numbers and 0 are falsy.</p>
<p><code class="docutils literal notranslate"><span class="pre">List</span></code> is an intrinsic type implemented in the Prelude.
<code class="docutils literal notranslate"><span class="pre">List(at:Indexer,</span> <span class="pre">count:Num)</span></code> is defined as an indexing function
<code class="docutils literal notranslate"><span class="pre">constraint</span> <span class="pre">Indexer(i:Num)</span></code> and a numerical count. <code class="docutils literal notranslate"><span class="pre">List</span></code> has no
special compiler support except that instances can be serializable when
the return type of <code class="docutils literal notranslate"><span class="pre">at:Indexer</span></code> is serializable. <code class="docutils literal notranslate"><span class="pre">List</span></code>
serialization is performed by evaluating all elements.</p>
</div>
<div class="section" id="host-environments">
<h2>Host Environments<a class="headerlink" href="#host-environments" title="Permalink to this headline">Â¶</a></h2>
<p>An Element program exists in context of a hosting environment (host) for
dealing with it. Hosts are libraries or programs providing facilities
for parsing, validating, analysing, compiling and evaluating Element
source directly (interpreting) or transforming them into another format
for export or transport.</p>
<div class="section" id="top-level-functions">
<h3>Top-level Functions<a class="headerlink" href="#top-level-functions" title="Permalink to this headline">Â¶</a></h3>
<p>An Element program is always a function (referred to as the top-level
function) that takes inputs and returns outputs when the program is run.
There is no notion of a âmainâ function - any function that meets data
boundary criteria may be compiled by a host. Top-level functions must
only have serializable values on their interface.</p>
</div>
<div class="section" id="compilation">
<h3>Compilation<a class="headerlink" href="#compilation" title="Permalink to this headline">Â¶</a></h3>
<p>Compiling involves starting with the outputs and recursively analysing
all dependencies. Resolving type constraints statically relies on
recursive compilation of dependencies. Output values necessarily have
concrete types that are checked against constraints as the dependency
graph is traversed. All constraints can be checked during compilation
with no type checking requiring deference until runtime.</p>
<p>Another important consequence of recursive analysis is that unreferenced
values are not compiled. This is a double-edged sword as it improves
compilation performance but allows errors in unreferenced code that
parses successfully (such as type errors) to go undetected!</p>
<p>Hosts must follow the error handling conventions defined in
<a class="reference external" href="../Laboratory/README.md">Laboratoryâs readme</a>.</p>
</div>
<div class="section" id="data-boundary">
<h3>Data Boundary<a class="headerlink" href="#data-boundary" title="Permalink to this headline">Â¶</a></h3>
<p>Element has no facilities for dealing with storage/memory thus a host
must be responsible for handling memory for an Element program.
Boundaries occur when an Element program relies on the host for handling
memory. This happens in two situations:</p>
<ul class="simple">
<li><p>when passing the inputs to and receiving outputs from the function being compiled</p></li>
<li><p>in the iteration state values of <code class="docutils literal notranslate"><span class="pre">persist</span></code> and <code class="docutils literal notranslate"><span class="pre">for</span></code> intrinsic calls.</p></li>
</ul>
<div class="section" id="serialization">
<h4>Serialization<a class="headerlink" href="#serialization" title="Permalink to this headline">Â¶</a></h4>
<p>Only serializable values can be passed across the boundary. Serializable
values are those which can be translated into a sequence of primitive
data - numbers in Elements case. The following value types are
serializable:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">Num</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">struct</span></code> instance containing only serializable fields - structures require mapping between host and Element types to match layout.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">List</span></code> which can be evaluated to only serializable elements - Lists will be evaluated to their elements when crossing the boundary.</p></li>
</ul>
<p>Hosts must have member mappings for <code class="docutils literal notranslate"><span class="pre">struct</span></code> types declared in the
prelude and may provide mappings for other structures.</p>
<p>All concrete types in a <code class="docutils literal notranslate"><span class="pre">List</span></code> must be mappable for a <code class="docutils literal notranslate"><span class="pre">List</span></code> to be
translatable.</p>
</div>
</div>
</div>
</div>


           </div>
           
          </div>
          <footer>
  
    <div class="rst-footer-buttons" role="navigation" aria-label="footer navigation">
      
        <a href="UserGuide.html" class="btn btn-neutral float-right" title="User Guide" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right"></span></a>
      
      
        <a href="index.html" class="btn btn-neutral float-left" title="Element Documentation" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left"></span> Previous</a>
      
    </div>
  

  <hr/>

  <div role="contentinfo">
    <p>
        
        &copy; Copyright 2020, Ultraleap

    </p>
  </div>
    
    
    
    Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a
    
    <a href="https://github.com/rtfd/sphinx_rtd_theme">theme</a>
    
    provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>

        </div>
      </div>

    </section>

  </div>
  

  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script>

  
  
    
   

</body>
</html>